# 实现棋盘+小球碰撞模型
# 棋盘
<font size=7>采用easyx库进行绘制，唯一的问题是考虑png背景问题，这个放在后面写</font>				
----
```
#undef UNICODE
#undef _UNICODE//我的VS版本过高，要把unicode默认编码改成MBCS，这里取消unicode的宏定义
#include<graphics.h>
#include<conio.h>
#include<easyx.h>
#include<iostream>

using namespace std;

IMAGE img,zhezhao,yuan;

void qipan();//棋盘
void lineandpoint();//线点
void cursor();//光标
void indicator();//提示
void qizibai(int size_x,int size_y,int position_x,int position_y);//利用位运算消除背景色并导入棋子
void qizihei(int size_x,int size_y,int position_x,int position_y);//利用位运算消除背景色并导入棋子

int main()
{
  qipan();
  indicator();
  cin.get();
  return 0;
}


void qipan()
{
  initgraph(960,800);
  loadimage(&img,"back.jpg",960,800);//这里改成自己图片的名字
  putimage(0,0,&img);//棋盘背景
  setlinecolor(BLACK);
  setlinestyle(PS_SOLID,3);
  rectangle(0,0,630,630);//框
  lineandpoint();//线，点
  cursor();//光标
}
void lineandpoint()
{
  setlinestyle(PS_SOLID,1);
  for(int x = 0; x <= 630; x += 30)
  {
    line(x,0,x,630);
  }
  for(int y = 0; y <= 630; y += 30)
  {
    line(0,y,630,y);
  }//框
  setfillcolor(BLACK);
  solidcircle(90,90,5);
  solidcircle(540,90,5);
  solidcircle(330,330,5);
  solidcircle(90,540,5);
  solidcircle(540,540,5);//点
}
void cursor()
{
  setlinecolor(RED);
  rectangle(315,315,345,345);
}


void indicator()
{
  setlinecolor(BLACK);
  settextcolor(BLACK);
  settextstyle(32, 0, "Consolas");
  setbkmode(TRANSPARENT);
  rectangle(650,50,850,250);
  char s1[]="出棋方";
  char s2[]="wasd移动光标,空格落棋,ESC退出";
  outtextxy(715,270,s1);
  outtextxy(20,700,s2);
  qizihei(150,150,670,70);
}


void qizibai(int size_x,int size_y,int position_x,int position_y)
{
  loadimage(&yuan,"bai.png",size_x,size_y);//这里改成自己图片的名字
  loadimage(&zhezhao,"baibk.png",size_x,size_y);//这里改成自己图片的名字
  putimage(position_x, position_y ,&zhezhao, SRCAND);//添加位运算宏
	putimage(position_x, position_y, &yuan, SRCPAINT);
}
void qizihei(int size_x,int size_y,int position_x,int position_y)
{
  loadimage(&yuan,"hei.png",size_x,size_y);//这里改成自己图片的名字
  loadimage(&zhezhao,"heibk.png",size_x,size_y);//这里改成自己图片的名字
  putimage(position_x, position_y ,&zhezhao, SRCAND);//添加位运算宏
	putimage(position_x, position_y, &yuan, SRCPAINT);
}
```
### 讲一下png消除背景的方法
<font size=7>网上找了很多方法，这是唯一一个成了的，简单来说就是利用位运算消除背景，原文链接如下   </font> 
<https://blog.csdn.net/m0_60777643/article/details/122833558>      
<font size=7>利用ps扣出黑底原彩图+白底黑像图，注意把所有png文件全部放到项目文件夹里面，或者新建个文件夹自己改路径</font>

# 小球碰撞模型
<font size=7>纯数学知识，碰撞后设定交换速度</font>
### 代码
```
#include <conio.h>
#include <graphics.h>
#include <time.h>
#define number 5
typedef struct Ball
{
	int ball_x;
	int ball_y;
	int ball_vx;
	int ball_vy;
	int distance[2];		//记录某个小球，距离它最近的小球的距离，以及这个小球的下标
}Ball;
Ball balls[number];

void get_distance(struct Ball balls[number]);//求距离
void knock(struct Ball balls[number]);//判断是否碰撞

int main()
{
	srand((unsigned)time(NULL));
	for(int i=0;i<number;i++)
	{
		balls[i].ball_x=rand()%860+20;
		balls[i].ball_y=rand()%680+20;
		for(int j=0;j<number;j++)
      if(i!=j)
      {
        if((balls[i].ball_x>=balls[j].ball_x-20)&&(balls[i].ball_x<=balls[j].ball_x+20)&&(balls[i].ball_y>=balls[j].ball_y-20)&&(balls[i].ball_y<=balls[j].ball_y+20))
        {
          balls[i].ball_x=rand()%860+20;
          balls[i].ball_y=rand()%680+20;
        }//防止小球重叠，对小球进行重新随机位置
      }
		balls[i].ball_vx=1+i;
		balls[i].ball_vy=1+i;//将小球速度设为不同，避免一直无法碰撞
	}
	for (int i=0;i<number;i++)
  {
    balls[i].distance[0] = 10000;
    balls[i].distance[1] = -1;
  }
	initgraph(900,720);
	BeginBatchDraw();
	while(1)
	{
		setfillcolor(BLUE);
		for(int i=0;i<number;i++)
		{
			fillcircle(balls[i].ball_x,balls[i].ball_y,20);
		}
		get_distance(balls);
		knock(balls);
		Sleep(2);
		FlushBatchDraw();
		setcolor(BLACK);
		setfillcolor(BLACK);
		for(int i=0;i<number;i++)
		{
			fillcircle(balls[i].ball_x,balls[i].ball_y,20);
			balls[i].ball_x=balls[i].ball_x+balls[i].ball_vx;
			balls[i].ball_y=balls[i].ball_y+balls[i].ball_vy;
			if(balls[i].ball_x<=20||balls[i].ball_x>=880)
				balls[i].ball_vx=-balls[i].ball_vx;
			if(balls[i].ball_y<=20||balls[i].ball_y>=700)
				balls[i].ball_vy=-balls[i].ball_vy;
		}//交换速度
	}
	EndBatchDraw();
	closegraph();
	return 0;
}

void get_distance(struct Ball balls[number])
{
	for (int i=0;i<number;i++)
	{
		for (int j=0;j<number;j++)
		{
			if (i!=j)
			{
        int dist2;
        dist2 = (balls[i].ball_x - balls[j].ball_x)*(balls[i].ball_x - balls[j].ball_x)+(balls[i].ball_y - balls[j].ball_y)*(balls[i].ball_y - balls[j].ball_y);
        if (dist2<balls[i].distance[0])
        {
          balls[i].distance[0] = dist2;
          balls[i].distance[1] = j;
        }
      }
		}
	}
}

void knock(struct Ball balls[number])
{
  for (int i=0;i<number;i++)
  {
    if (balls[i].distance[0]<=4*(20*20))
    {
      int j = balls[i].distance[1];            
      int temp;
      temp = balls[i].ball_vx; balls[i].ball_vx = balls[j].ball_vx; balls[j].ball_vx = temp;
      temp = balls[i].ball_vy; balls[i].ball_vy = balls[j].ball_vy; balls[j].ball_vy = temp;
      balls[j].distance[0] = 10000; 
      balls[j].distance[1] = -1;
      balls[i].distance[0] = 10000; 
      balls[i].distance[1] = -1;
    }
  }
}
```
