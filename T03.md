# 题目
<img width="619" alt="image" src="https://user-images.githubusercontent.com/96159597/169768674-239cc39e-d629-4bd3-bba7-58dcc90b633d.png">

-----
# 解题思路
<font size=7>这道题我的解法比较复杂，运用的是链表的尾插和删除       </font>     
<font size=7>注意到三个线性表都是非降序排列的，其实可以直接用三个顺序表或者数组来建立</font>

# 代码
```
#include<stdio.h>
#include<stdlib.h>

typedef struct node{
  int value;
  struct node *next;
}LNode;

void initlist(LNode *l,int n);//初始化单链表并输入数据
void comparelist(LNode *b,LNode* c,int *num);//比较bc字符串找到相同元素
void shanchu(LNode *a,int *num);//删除重复元素
void output(LNode *a);//输出

int main()
{
  int n1,n2,n3;
  LNode *a,*b,*c;
  int num[100];
  a = (LNode*)malloc(sizeof(LNode));
  b = (LNode*)malloc(sizeof(LNode));
  c = (LNode*)malloc(sizeof(LNode));
  scanf("%d%d%d",&n1,&n2,&n3);
  initlist(a,n1);
  initlist(b,n2);
  initlist(c,n3);
  comparelist(b,c,num);
  shanchu(a,num);
  output(a);
  getchar();
  getchar();
  return 0;
}

void initlist(LNode *l,int n)
{
  int s;
  LNode *r;
  l->next = NULL;
  r = l;
  for(int i=0;i<n;i++)
  {
    LNode *p;
    p = (LNode*)malloc(sizeof(LNode));
    scanf("%d",&s);
    p->value = s;
    p->next = NULL;
    r->next = p;
    r = p;
  }
}
void comparelist(LNode *l1,LNode *l2,int *num)
{
  int i = 0;
  while(l1->next && l2->next)
  {
    if(l1->next->value == l2->next->value)
    {
      num[i] = l1->next->value;
      i++;
      l1->next = l1->next->next;
    }
    else if (l1->next->value > l2->next->value)
      l2->next = l2->next->next;
    else
      l1->next = l1->next->next;
  }
  num[i] = 99999999;
}
void shanchu(LNode *l,int *num)
{
  int i=0;
  LNode *pc = l;
  while(pc->next && num[i]!=99999999)
  {
    if(pc->next->value == num[i])
    {
      pc->next=pc->next->next;
      pc=pc->next;
    }
    else if(pc->next->value > num[i])
      i++;
    else
      pc=pc->next;
  }
}
void output(LNode *l)
{
  while(l->next)
  {
    printf("%d ",l->next->value);
    l->next = l->next->next;
  }
}
```


