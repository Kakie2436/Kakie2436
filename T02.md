#   题目
<img width="614" alt="image" src="https://user-images.githubusercontent.com/96159597/169685873-d50f8a56-3a99-4dc3-9215-3e3fd0af60b7.png">      

#   基本思路
<font size=7>面向AC编程的话直接倒序输出就行，简单粗暴，正经做法如下，依次为数组，单链表</font>        
#   代码_数组
```
#include<stdio.h>
#include<stdlib.h>

int main()
{
  int a[100];
  int n;
  scanf("%d",&n);
  for(int i=0;i<n;i++)
    scanf("%d",&a[i]);
  int temp;
  for(int i=0;i<n/2;i++)//若为奇数最中间的元素不会进入循坏，保持原位
  {
    temp = a[0+i];
    a[0+i] = a[n-1-i];
    a[n-1-i] = temp;
  }
  for(int i=0;i<n;i++)
    printf("%d ",a[i]);
  getchar();
  getchar();
}
```
# 单链表
<font size=7>我们知道头插法是逆序存储的，例如输入为4，3，2，1，那么存储先后实际上为1，2，3，4，即先输入的数据是存储在单链表的尾部，利用这一特性可以直接写一个头插法完成逆置</font>          
<font>关于头插法的知识可以见如下链接</font>        
[头插法原理](https://blog.csdn.net/cainiaofu/article/details/108434499?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%A4%B4%E6%8F%92%E6%B3%95&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-108434499.142^v10^control,157^v4^control&spm=1018.2226.3001.4187>)          
[头插法实现链表逆置](https://blog.csdn.net/weixin_45380782/article/details/123969804?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%A4%B4%E6%8F%92%E6%B3%95&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-123969804.142^v10^control,157^v4^control&spm=1018.2226.3001.4187)

# 代码_单链表
```
#include<stdio.h>
#include<stdlib.h>

typedef struct node{
  int value;
  struct node *next;
}LNode;

int main()
{
  LNode *head = (LNode*)malloc(sizeof(LNode));//建立头结点
  LNode *s;
  head->next = NULL;
  int n,data;
  scanf("%d", &n);
  for(int i=0;i<n;i++)
  {
    scanf("%d",&data);
    s = (LNode*)malloc(sizeof(LNode));
    s->value = data;
    s->next = head->next;
    head->next = s;
  }
  LNode *p;
  p = head->next;
  for(int i=0;i<n;i++)
  {
    printf("%d ",p->value);
    p=p->next;
  }
  getchar();
  getchar();
}
```

