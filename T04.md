# 题目

<img width="621" alt="image" src="https://user-images.githubusercontent.com/96159597/170268871-58e4970f-9937-4e84-884b-36826a49f3bd.png">

----

# 基本思路

<font size=7>题目明确规定了是两个单链表，而且不能够开辟新的空间，注意到最后是倒序输出，故可以利用尾插法建立两个链表，再利用头插法合并为新链表</font>

----

# 代码
```
#include<stdio.h>
#include<stdlib.h>

typedef struct node{
  int value;
  struct node *next;
}LNode;

void initlist(LNode *l,int n);
void guibing(LNode *l1,LNode *l2,LNode *l3);
void output(LNode *l);

int main()
{
  int n1,n2;
  LNode *l1,*l2,*l3;
  l1=(LNode*)malloc(sizeof(LNode));
  l2=(LNode*)malloc(sizeof(LNode));//题目要求是用l1,l2的空间，故l3不另外开辟
  scanf("%d%d",&n1,&n2);
  initlist(l1,n1);
  initlist(l2,n2);
  guibing(l1,l2,l3);
  output(l3);
  getchar();
  getchar();
}
void initlist(LNode *l,int n)
{
  l->next = NULL;
  LNode *r;
  r = l;
  for(int i=0;i<n;i++)
  {
    LNode *p;
    p = (LNode*)malloc(sizeof(LNode));
    scanf("%d",&p->value);
    p->next = NULL;
    r->next = p;
    r = p;
  }
}
void guibing(LNode *l1,LNode *l2,LNode *l3)
{
  LNode* p1=l1->next;
	LNode* p2=l2->next;
	while(p1&&p2){
		LNode* p=(LNode*)malloc(sizeof(LNode*));
		if((p1->value)>(p2->value)){
			p->value=p2->value;
			p2=p2->next;
			p->next=l3->next;
			l3->next=p;
		}
		else if((p1->value)<(p2->value)){
			p->value=p1->value;
			p1=p1->next;
			p->next=l3->next;
			l3->next=p;
		}
		else{
			p->value=p1->value;
			p2=p2->next;
			p->next=l3->next;
			l3->next=p;
		}
	}
	while(p1){
		LNode* p=(LNode*)malloc(sizeof(LNode*));
		p->value=p1->value;
		p1=p1->next;
		p->next=l3->next;
		l3->next=p;
	}
	while(p2){
		LNode* p=(LNode*)malloc(sizeof(LNode*));
		p->value=p2->value;
		p2=p2->next;
		p->next=l3->next;
		l3->next=p;
	}
}
void output(LNode *l)
{
  while(l->next)
  {
    printf("%d ",l->next->value);
    l->next = l->next->next;
  }
}
```
